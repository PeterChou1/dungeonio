import { Player } from "./player";
import { messageType, gameConfig } from "../../common/config/globalConfig";
import { AOImanager } from "../interest/aoi.manager";
import { Engine, World, Render, Events, use } from "matter-js";
import { generateFrameTiming } from "../utils/utils";
import { parsetiled } from "../tiledparser/tileparse";
import { playerAnims } from "../../common";
//import matter collision events
require("../utils/matter-collision");
//install plugin matterjs
use("matter-collision-events");

//declare document for injection into client side code
declare let document: any;
/**
 * Core game engine loop
 */
export class Game {
  private clearid;
  private engine;
  // stores simulate player instances
  private allplayers: {
    [id: string]: Player;
  };
  // how much time has elaspsed since start of simulation
  private elaspsedtime = 0;
  // number tracking how ahead or behind the gameloop is
  // accumulator > tickrate === gameloop is behind
  // accumulator < tickrate === gameloop is ahead
  private accumulator = 0;
  // tick rate is in ms
  //(Game loop) 60fps
  private tickrate = 1000 / 60;
  //(Broad cast loop) per 10 updates per second
  private updaterate = 1000 / 10;
  // game timer
  private gametimer;
  // update timer for broadcast to client
  private updatetimer;
  // colyseus.js room
  private room;
  private aoimanager: AOImanager;
  private render;
  private previoustick;
  // frame data of player character
  framesInfo;
  frameData;
  // level details
  objectgroup;

  constructor(room?) {
    this.engine = Engine.create({
      enableSleeping: true, // perf optimzation for engine
    });
    /* setup level using tile map data*/
    const tilemap = require("../../client/assets/tilemaps/json/level2.json");
    this.objectgroup = parsetiled(
      this.engine,
      tilemap,
      { ground: "mainlevbuild" },
      ["platform"]
    );
    /* generate animation timing using configuration object */
    this.framesInfo = generateFrameTiming(playerAnims);
    /* load frame data generated by physics editor */
    this.frameData = require("../../client/assets/frameData.json");
    this.allplayers = {};
    console.log(`running at tick rate ${Math.trunc(this.tickrate)}m`);
    if (gameConfig.networkdebug) {
      this.clearid = setInterval(this.updateGame.bind(this), this.tickrate);
      this.render = Render.create({
        element: document.getElementById("debug"),
        engine: this.engine,
      });
      // run the renderer
      Render.run(this.render);
    } else {
      this.previoustick = this.hrtimeMs();
      this.aoimanager = new AOImanager();
      const NanoTimer = require("nanotimer");
      this.gametimer = new NanoTimer();
      this.updatetimer = new NanoTimer();
      this.updatetimer.setInterval(
        this.broadcastClients.bind(this),
        "",
        `${Math.trunc(this.updaterate)}m`
      );
      this.gametimer.setInterval(
        this.updateGame.bind(this),
        "",
        `${Math.trunc(this.tickrate)}m`
      );
      this.room = room;
      this.room.onMessage(messageType.playerinput, (client, playerinput) => {
        this.allplayers[client.sessionId].updatePlayerInput(playerinput);
      });
      this.room.onMessage(messageType.playersleep, (client) => {
        this.allplayers[client.sessionId].setInternalState({ asleep: true });
      });
      this.room.onMessage(messageType.playerawake, (client) => {
        this.allplayers[client.sessionId].setInternalState({ asleep: false });
      });
    }
  }

  private hrtimeMs() {
    let time = process.hrtime();
    return time[0] * 1000 + time[1] / 1000000;
  }

  updateGame() {
    if (gameConfig.networkdebug) {
      this.simulateTick();
    } else {
      let now = this.hrtimeMs();
      let delta = now - this.previoustick;
      this.accumulator += delta;
      while (this.accumulator >= this.tickrate) {
        // update game
        this.simulateTick();
        this.accumulator -= this.tickrate;
        this.elaspsedtime += this.tickrate;
      }
      this.previoustick = now;
    }
  }

  simulateTick() {
    for (const clientId in this.allplayers) {
      this.allplayers[clientId].update();
    }
    Engine.update(this.engine, this.tickrate);
  }

  broadcastClients() {
    this.aoimanager.aoibroadcast();
  }

  manualUpdateInput(clientId, playerinput) {
    this.allplayers[clientId].updatePlayerInput(playerinput);
  }

  manualGetState(clientId) {
    return this.allplayers[clientId].getState();
  }

  addPlayer(client, name) {
    // add in internal colyseus js
    this.allplayers[client.sessionId] = new Player(this, name, client, 96, 582);
    if (gameConfig.networkdebug && client.sessionId === "test") {
      Events.on(
        this.engine,
        "beforeUpdate",
        function () {
          this.allplayers["test"].setCamera(this.render);
        }.bind(this)
      );
    } else if (!gameConfig.networkdebug) {
      this.room.state.addPlayer(client.sessionId, name);
    }
  }

  removePlayer(client) {
    this.allplayers[client.sessionId].destroy();
    delete this.allplayers[client.sessionId];
    if (!gameConfig.networkdebug) {
      this.room.state.removePlayer(client.sessionId);
    }
  }

  destroy() {
    World.clear(this.engine.world);
    Engine.clear(this.engine);
    // destroy all players just in case
    for (const id in this.allplayers) {
      this.allplayers[id].destroy();
      delete this.allplayers[id];
    }
    if (gameConfig.networkdebug) {
      clearInterval(this.clearid);
    } else {
      this.gametimer.clearInterval();
      this.updatetimer.clearInterval();
    }
  }
}
